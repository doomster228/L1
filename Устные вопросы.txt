1. Какой самый эффективный способ конкатенации строк?

Использование оператора "+"
str := "Привет, " + "мир!"
Но при каждой конкатенации оператор "+" создает новую строку, что может привести к накоплению мусора и иметь негативное влияние на производительность, особенно при конкатенации большого количества строк.

Использование strings.Join()
str := strings.Join([]string{"Привет", "мир!"}, ", ")
Эта функция принимает срез строк в качестве аргумента и объединяет их в одну строку, разделяя их определенным разделителем.
Данный метод более предпочтителен, так как Join() выделяет достаточно памяти заранее для конечной строки и копирует в нее элементы только один раз.

Использование bytes.Buffer
var buffer bytes.Buffer
buffer.WriteString("Привет, ")
buffer.WriteString("мир!")
str := buffer.String()
Buffer является наиболее эффективным вариантом для конкатенации и изменения большого количества строк, так как позволяет избежать создания множества временных объектов и динамически увеличивает свой буфер при необходимости, минимизируя число аллокаций памяти



2. Что такое интерфейсы, как они применяются в Go?

В программировании интерфейс - это контракт, определяющий, набор методов, которые должны быть реализованы в классе или структуре, но не описывает их конкретную реализацию. 
Интерфейсы позволяют реализовать полиморфизм и обеспечить гибкость взаимодействия между различными типами данных.
В Go интерфейсы определяются с помощью ключевого слова interface и списком методов.

type Animal interface {
    Speak() string
    Move() string
}

type Cat struct {
    Name string
}

type Mouse struct {
    Name string
}

func (c Cat) Speak() string {
    return "Meow!"
}

func (c Cat) Move() string {
    return "Walking"
}

func (m Mouse) Speak() string {
    return "..."
}

func (m Mouse) Move() string {
    return "Running"
}

func Moving(a Animal) {
    fmt.Println(a.Move())
}

func main() {
    cat := Cat{Name: "Tom"}
    mouse := Mouse{Name: "Jerry"}

    Moving(cat) // Выводит "Walking"
    Moving(mouse) // Выводит "Running"
}

Интерфейс Animal определяет два метода: Speak() и Move(), которые должны быть реализованы в каждом объекте, реализующем данный интерфейс.
Эти методы реализованы в структуре Cat, что позволяет Cat быть объектом типа Animal. 
Если структура или класс реализуют все методы из интерфейса, то они автоматически считаются реализующими данный интерфейс.
Функция Moving() принимает аргумент типа Animal, и мы можем передать в нее как объект типа Cat, так и объект типа Mouse, потому что оба типа реализуют интерфейс Animal. 
Это обеспечивает гибкость при работе с различными типами объектов, позволяя нам обращаться к ним через общий интерфейс.



3. Чем отличаются RWMutex от Mutex?

Mutex и RWMutex - это структуры данных, которые используются для синхронизации доступа к общим ресурсам.
Основное отличие между Mutex и RWMutex заключается в том, как они управляют доступом к ресурсу.

Mutex является простой и основной структурой и предоставляет два метода: Lock() и Unlock(). 
Когда горутина вызывает Lock() на Mutex, она захватывает его и блокирует другие горутины до тех пор, пока она не вызовет Unlock() для его освобождения. 
В этом случае только одна горутина может использовать ресурс одновременно.

RWMutex (Read-Write Mutex) также имеет методы Lock() и Unlock(), но он также предоставляет методы RLock() и RUnlock(), которые позволяют получить и освободить разделяющую блокировку.
Разделяющая блокировка позволяет нескольким горутинам одновременно читать общий ресурс, но только одной горутине писать в него. 
Когда горутина вызывает метод RLock(), она получает разделяющую блокировку и блокирует любые попытки вызова Lock(), чтобы гарантировать, что никто не будет пытаться изменить ресурс до освобождения блокировки.
Использование RWMutex может увеличить параллелизм программы в тех случаях, когда большая часть операций с общим ресурсом является чтением, так как несколько горутин могут читать его одновременно, но только одна может его изменять.
RWMutex дороже в плане производительности, по сравнению с Mutex, поэтому его следует использовать только там, где это действительно необходимо.



4. Чем отличаются буферизированные и не буферизированные каналы?

Небуферизированные каналы являются блокирующими, что означает, что отправка и получение данных через них приводит к блокировке горутины до тех пор, пока другая горутина не будет готова принять или отправить данные. 
Это означает, что отправитель будет заблокирован, пока получатель не получит данные, а получатель будет заблокирован, пока отправитель не отправит данные. 
Этот механизм обеспечивает синхронизацию между горутинами, что позволяет избежать состояний гонки и других проблем, связанных с параллельным выполнением.

Буферизированные каналы имеют определенный размер буфера. Они позволяют отправителю и получателю взаимодействовать асинхронно. 
Когда отправитель отправляет данные в буферизированный канал, он не блокируется, если буфер еще не полон. 
Аналогично, когда получатель извлекает данные из буферизированного канала, он не блокируется, если буфер еще не пуст. 
Блокировка происходит только в случае, если буфер полностью заполнен и отправитель пытается отправить новые данные, или если буфер пуст и получатель пытается извлечь данные.

Небуферизированные каналы подходят для точной синхронизации и обмена данными между горутинами, в то время как буферизированные каналы могут быть полезными для асинхронной обработки данных.



5. Какой размер у структуры struct{}{}?

Размер структуры struct{}{} равен нулю, потому что структура не занимает память, если в ней отсутствуют поля или методы.
Такие структуры называются пустыми структурами или пустыми типами и обычно нужны, когда мы хотим создать тип данных без каких-либо полей. 
Например, она может использоваться в качестве типа данных для канала, когда мы хотим передавать сигналы без дополнительной информации или для реализации интерфейса, который не содержит никаких данных, либо в качестве "маркера", чтобы указать на присутствие некоторой функциональности или реализации.

 
 
6. Есть ли в Go перегрузка методов или операторов?

Нет. Вместо перегрузки методов Go использует именованные аргументы и пустые интерфейсы. 
Если требуется создать различные версии метода для разных типов, необходимо явно указать это в именах методов или использовать интерфейсы для обработки разных типов.

Вместо перегрузки операторов Go предлагает набор встроенных операторов, которые работают со встроенными типами данных. 
Если требуется реализовать специальное поведение операторов для своего пользовательского типа данных, необходимо явно определить методы для этого типа.



7. В какой последовательности будут выведены элементы map[int]int?

Порядок вывода элементов map[int]int может быть случайным и зависит от реализации конкретного компилятора и версии Go. 
Map является неупорядоченной структурой данных, поэтому не существует гарантии, что элементы будут выводиться в определенном порядке. 
Каждый раз при итерации по map[int]int, порядок элементов может изменяться. 
Если требуется определенный порядок элементов, то следует использовать другую структуру данных, такую как слайс или массив.



8. В чем разница между make и new?

Ключевое слово "make" используется для создания срезов, отображений и каналов, тогда как "new" используется для выделения памяти и инициализации одиночных значений указателя на тип данных.

Функция "make" создает и инициализирует срезы, отображения и каналы, осуществляя скрытые инициализации, необходимые для правильной работы этих типов данных. 
Например, при создании среза с помощью "make" выделится память под элементы среза, а также будут инициализированы дополнительные поля для управления его емкостью и длиной.

slice := make([]int, 0, 10)

Функция "new" используется для выделения памяти в куче и инициализации указателя на тип данных. 
Она возвращает указатель на новый нулевой объект нужного типа, но, в отличие от "make", не выполняет дополнительных инициализаций для срезов, отображений и каналов, вместо этого она просто возвращает указатель на нулевое значение указанного типа данных.

var numPointer *int
numPointer = new(int)

Таким образом, разница между "new" и "make" в Go заключается в том, что "new" возвращает указатель на выделенную память, тогда как "make" инициализирует и возвращает сам объект (значение).



9. Сколько существует способов задать переменную типа slice или map?

Через литералы:

- Slice: можно создать пустой срез используя var или :=, например: var mySlice []int или mySlice := []int{}. Также можно создать срез с начальными значениями: mySlice := []int{1, 2, 3}.

- Map: можно создать пустое отображение используя var или :=, например: var myMap map[string]int или myMap := map[string]int{}. Также можно создать отображение с начальными значениями: myMap := map[string]int{"a": 1, "b": 2, "c": 3}.

Через функции:

- Slice: можно использовать функцию make, которая создает и инициализирует срез указанной длины и емкости. Например: mySlice := make([]int, 5) создаст срез с пятью элементами.

- Map: можно использовать функцию make, которая создает и инициализирует отображение указанной емкости. Например: myMap := make(map[string]int, 10) создаст отображение с начальной емкостью 10.

Через присваивание:

- Slice: можно присвоить значение существующего среза другому срезу. Например: mySlice := []int{1, 2, 3}; anotherSlice := mySlice.

- Map: можно присвоить значение существующего отображения другому отображению. Например: myMap := map[string]int{"a": 1, "b": 2, "c": 3}; anotherMap := myMap.



10. Что выведет данная программа и почему?

func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}


Результат:
1
1

В функции update мы изменяем значение указателя p, но не его целевое значение. 
Мы присваиваем указателю p адрес переменной b, но после выполнения функции update, указатель p на самом деле указывает на аргумент b внутри функции update, а не на переменную a в функции main.
Поэтому, когда мы возвращаемся в функцию main и пытаемся вывести значение по указателю p, он все еще указывает на переменную a, которая осталась неизменной, поэтому выводится ее исходное значение, равное 1.



11. Что выведет данная программа и почему?

func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}


Результат:
0
1
2
3
4
fatal error: all goroutines are asleep - deadlock!

* Числа выводятся в случайном порядке

При запуске программы, создается объект sync.WaitGroup, после чего запускается цикл, который выполняется пять раз. 
На каждой итерации цикла вызывается метод wg.Add(1), который увеличивает счетчик ожидаемых горутин на 1. 
Затем создается горутина, внутри которой вызывается функция, принимающая два аргумента: объект sync.WaitGroup и значение переменной i.
Функция внутри горутины выводит значение i и затем вызывает метод wg.Done(), который уменьшает счетчик ожидаемых горутин на 1, что позволяет объекту sync.WaitGroup отслеживать завершение работы всех горутин.
После создания горутин и вызова метода wg.Wait(), программа ждет завершения работы всех горутин, а потом появляется ошибка.
Эта ошибка возникает из-за того, что счетчик синхронизации wg не уменьшается внутри анонимной функции, которая запускается в горутине. 
Вместо этого, каждая горутина получает свою собственную копию объекта WaitGroup. 
Таким образом, когда горутина выполняет wg.Done(), она уменьшает счетчик своей собственной копии WaitGroup, а не синхронизируется с объектом wg в функции main.
Когда все горутины завершают свою работу, программа продолжает выполнение и вызывает wg.Wait(). 
Но поскольку каждая горутина своей копии WaitGroup была уменьшена только самой собой, счетчик wg в функции main остается неизменным и не достигает значения 0, что приводит к блокированию (deadlock).
Чтобы исправить это, в анонимную функцию необходимо передавать указатель на объект WaitGroup, а не сам объект, чтобы все горутины использовали одну и ту же общую копию WaitGroup.
То есть анонимная функция внутри цикла будет выглядеть так:

go func(wg *sync.WaitGroup, i int) {
	fmt.Println(i)
	wg.Done()
}(&wg, i)




12. Что выведет данная программа и почему?

func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}


Результат:
0

Из-за использования оператора ":=" внутри блока условия if объявляется новая переменная и значение присваивается ей, а не той "n", которая была объявлена вне блока if. 
Поэтому, хотя внутри блока "n" с помощью оператора "++" увеличивается на 1, это не влияет на значение переменной "n" вне блока, которая остается равной 0, и именно это значение будет выведено на экран с помощью функции fmt.Println.



13. Что выведет данная программа и почему?

func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}


Результат:
[100, 2, 3, 4, 5]

При вызове функции someAction(a, 6), функция получает срез a переданного типа []int8 и значение 6 типа int8. 
Внутри функции, элемент v[0] изменяется на 100. 
В строке v = append(v, b) создается новый срез, который содержит все элементы исходного среза v, а также новый элемент b, но т.к. это новый срез внутри функции, то это изменение не будет отражено на оригинале среза a, который был объявлен в функции main. 
Поэтому, при вызове fmt.Println(a) в функции main, будет выведен срез a, в котором было изменено лишь нулевой элемент.



14. Что выведет данная программа и почему?

func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}


Результат:
[b b a][a a]

Причина такого вывода связана с тем, что функция внутри func(slice []string) работает с копией среза slice. 
Внутри функции происходит добавление элемента "a" с помощью функции append, а затем изменение значений первых двух элементов на "b". 
Однако эти изменения видны только внутри функции, так как она работает с копией среза. 
После выполнения функции, оригинальный срез не изменяется, и при последующем выводе значения остаются неизменными.
Чтобы внутри функции менялся исходный срез, нужно передать его не как значение, а в качестве указателя.
То есть анонимная функция будет выглядеть так:

func(slice *[]string) {
	*slice = append(*slice, "a")
	(*slice)[0] = "b"
	(*slice)[1] = "b"
	fmt.Print(*slice)
}(&slice)